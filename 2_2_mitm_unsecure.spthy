theory ManInTheMiddleUnsecure
begin

builtins: signing

/*
 * Premesse:
 * - C'e' piu' di un server
 * - C'e' piu' di un client
 * - Un client utilizza una sola coppia di chiavi per accedere a tutti i server in cui si registra
 *
 * Obiettivo:
 * - Far autenticare il client al server dimostrando che il client possiede la chiave privata, ma senza rivelarla
 *
 * Setup:
 * - Ogni client genera una propria coppia di chiavi (sk, pk)
 * - Il client si registra ad un server condividendo la chiave pubblica
 *
 * Protocollo:
 * - Il server genera una challenge ch e la invia al client
 * - Il client riceve ch, calcola la response sig=pk(ch, sk) e la invia al server
 * - Il server riceve sig e verifica la firma verify(sig, ch, pk):
 *  - Se true, allora autentica il client
 *  - Altrimenti, rifiutalo
 * 
 * Attacco:
 * - S1 invia una challenge al client, ma viene intercettata dall'attaccante
 * - Lâ€™attaccante, spacciandosi per S2, invia la challenge intercettata al client
 * - Il client invia una response all'attaccante
 * - L'attaccante si autentica ad S1 usando la response ricevuta
 * 
 * Obiettivo di sicurezza:
 * - Se il server ha accettato un client, allora quest'ultimo deve aver risposto in precedenza
 */

// Un client genera una coppia di chiavi.
rule Setup:
    [ Fr(~sk) ]
  --[ ClientGenerates($C, ~sk, pk(~sk)) ]->
    [ !ClientSK($C, ~sk),
      !ClientPK($C, pk(~sk)),
      Out(pk(~sk)) ]

// Ogni client deve avere una sola coppia di chiavi.
restriction ClientGeneratesOnce:
  "All c skey1 skey2 pkey1 pkey2 #i #j.
    ClientGenerates(c, skey1, pkey1) @i
    & ClientGenerates(c, skey2, pkey2) @j
    ==>
    #i = #j"

// Un client si registra presso un server.
rule Register:
    [ !ClientPK(c, pkey) ]
  --[ ClientRegisters(c, $S, pkey) ]->
    [ !ServerPK($S, c, pkey) ]

// Ogni client si puo' registrare ad uno stesso server al piu' una volta sola.
restriction ClientRegistersOnce:
  "All c s pkey #i #j.
    ClientRegisters(c, s, pkey) @i
    & ClientRegisters(c, s, pkey) @j
    ==>
    #i = #j"

// Il server invia una challenge al client.
rule Challenge:
    [ !ServerPK(s, c, pkey),
      Fr(~ch) ]
  --[ ServerSendsCH(s, c, ~ch) ]->
    [ ServerWaitingSIG(s, c, ~ch),
      Out(<'Challenge', s, c, ~ch>) ]

// Il client riceve la challenge, la firma e la invia al server.
/*
 * L'identita' del server non e' inclusa nella firma => L'attaccante puo' riutilizzare la response.
 * Per impedire l'attacco, e' sufficiente aggiungere nella firma l'identita' del server:
 * sign(ch, skey)) -> sign(<ch, s>, skey)
 */
rule Response:
    [ In(<'Challenge', s, c, ch>),
      !ServerPK(s, c, pkey),
      !ClientSK(c, skey) ]
  --[ ClientResponds(c, s, ch, sign(ch, skey)) ]->
    [ Out(<'Response', c, s, ch, sign(ch, skey)>) ]

// Il server riceve la firma e verifica che sia corretta.
// verify(sig, ch, pkey) -> verify(sig, <ch, s>, pkey)
rule Verify:
    [ In(<'Response', c, s, ch, sig>),
      ServerWaitingSIG(s, c, ch),
      !ServerPK(s, c, pkey) ]
  --[ Eq(verify(sig, ch, pkey), true),
      ServerAccepts(s, c, ch, sig) ]->
    [ ]

// Ogni volta che viene usata l'equazione Eq(x, y), x deve essere uguale a y.
restriction Equality:
  "All x y #i.
    Eq(x, y) @i
    ==>
    x = y"

// Rivela la chiave segreta di un client.
rule RevealSK:
    [ !ClientSK(c, skey) ]
  --[ Reveal(c) ]->
    [ Out(skey) ]

// -----------------------------LEMMI DA DIMOSTRARE-----------------------------

// Se il server ha accettato un client, allora quest'ultimo deve aver risposto in precedenza.
// Non e' rispettato: C risponde a S2, ma S1 accetta.
lemma ServerAcceptsOnlyIfClientResponded:
  "All c s ch sig #i.
    ServerAccepts(s, c, ch, sig) @i &
    not (Ex #z. Reveal(c) @z & #z < #i)
    ==>
    (Ex #j. ClientResponds(c, s, ch, sig) @j & #j < #i)"

end