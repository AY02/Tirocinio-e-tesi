theory ManInTheMiddleAttackSecure
begin

builtins: signing

/*

Premesse:
- C'e' piu' di un client
- C'e' piu' di un server
- Il client usa una coppia di chiavi diversa per ogni server su cui si registra.

Protocollo:
1) Un client invia una auth request ad un server su cui si e' registrato.
2) Il server riceve la request e invia una challenge al client.
3) Il client firma la challenge e la invia la response al server.
4) Il server verifica la response e autentica il client.

*/

// Un client si registra presso un server.
rule ClientRegistration:
  [ Fr(~sk) ]
  --[ ClientRegisters($Client, $Server) ]->
  [ !ClientSK($Client, $Server, ~sk),
    !ServerPK($Server, $Client, pk(~sk)),
    Out(pk(~sk)) ]

// Un client si può registrare ad un server al più una volta.
restriction UniqueRegistration:
  "All c s #i #j.
    ClientRegisters(c, s) @i &
    ClientRegisters(c, s) @j
    ==>
    #i = #j"

// Un client invia una auth request al server.
rule ClientSendsAuthRequest:
  [ !ClientSK($Client, $Server, sk) ]
  --[ ClientRequestsAuth($Client, $Server) ]->
  [ ClientWaitingChallenge($Client, $Server),
    Out(<'Request', $Client, $Server>) ]

// Il server invia una challenge al client.
rule ServerSendsChallenge:
  [ In(<'Request', $Client, $Server>),
    !ServerPK($Server, $Client, pk),
    Fr(~challenge) ]
  --[ ServerSendsChallenge($Server, $Client, ~challenge) ]->
  [ ServerWaitingResponse($Server, $Client, ~challenge),
    Out(<'Challenge', $Server, $Client, ~challenge>) ]

// Il client firma la challenge e la invia al server.
rule ClientSendsResponse:
  [ In(<'Challenge', $Server, $Client, challenge>),
    ClientWaitingChallenge($Client, $Server),
    !ClientSK($Client, $Server, sk) ]
  --[ ClientResponds($Client, $Server) ]->
  [ Out(<'Response', $Client, $Server, sign(challenge, sk)>) ]

// Il server verifica la response e autentica il client.
rule ServerVerifiesResponse:
  [ In(<'Response', $Client, $Server, signature>),
    ServerWaitingResponse($Server, $Client, challenge),
    !ServerPK($Server, $Client, pk) ]
  --[ Eq(verify(signature, challenge, pk), true),
      ServerAccepts($Server, $Client) ]->
  [ ServerAuthenticated($Server, $Client) ]

/*
// Un server autentica un client al più una volta.
restriction unique_authentication:
  "All c s #i #j.
    ServerAccepts(s, c) @i &
    ServerAccepts(s, c) @j
    ==>
    #i = #j"
*/

// Ogni volta che viene usata l'equazione Eq(x, y), x deve essere uguale a y.
restriction Equality:
  "All x y #i.
    Eq(x,y) @i
    ==>
    x = y"

// Se il server accetta un client, allora quel client ha risposto.
lemma ClientResponded:
  "All s c #i.
    ServerAccepts(s, c) @i
    ==>
    (Ex #j. ClientResponds(c, s) @j & j < i)"

// Se il server invia una challenge, allora ha il client lo ha richiesto.
// Non e' rispettato: L'attaccante puo' inviare la request.
lemma ChallengeFollowsRequest:
  "All s c ch #i.
    ServerSendsChallenge(s, c, ch) @i
    ==>
    (Ex #j. ClientRequestsAuth(c, s) @j & j < i)"

end