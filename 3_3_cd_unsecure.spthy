theory CloneDetectionUnsecure
begin

builtins: signing

// Non ci sono piu' contatori.

// Un client genera una coppia di chiavi e si registra presso un server.
rule Setup:
    [ Fr(~sk) ]
  --[ ClientRegisters($c, $s, ~sk, pk(~sk)) ]->
    [ !ClientSK($c, $s, ~sk),
      !ServerPK($s, $c, pk(~sk)),
      Out(pk(~sk)) ]

// Ogni client si puo' registrare ad uno stesso server al piu' una volta sola.
// Ogni client genera una coppia di chiavi per quello stesso server al piu' una volta sola.
restriction ClientRegistersOnce:
  "All c s skey1 skey2 pkey1 pkey2 #i #j.
    ClientRegisters(c, s, skey1, pkey1) @i &
    ClientRegisters(c, s, skey2, pkey2) @j
    ==>
    #i = #j"

// Rivela la chiave segreta di un client (equivale alla clonazione).
rule RevealSK:
    [ !ClientSK(c, s, skey) ]
  --[ Reveal(c, s) ]->
    [ Out(skey) ]

// La reveal della chiave segreta di un client puo' essere fatta una sola volta.
restriction RevealOnce:
  "All c s #i #j.
    Reveal(c, s) @i &
    Reveal(c, s) @j
    ==>
    #i = #j"

// Il server invia una challenge al client.
rule Challenge:
    [ !ServerPK(s, c, pkey),
      Fr(~ch) ]
  --[ ServerSendsCH(s, c, ~ch) ]->
    [ ServerWaitingSIG(s, c, ~ch),
      Out(<'Challenge', s, c, ~ch>) ]

// Il client riceve la challenge, la firma e la invia al server.
rule Response:
    [ In(<'Challenge', s, c, ch>),
      !ClientSK(c, s, skey) ]
  --[ ResponseUsed(c, s),
      ClientResponds(c, s, ch, sign(ch, skey)) ]->
    [ Out(<'Response', c, s, ch, sign(ch, skey)>) ]

// Dopo la reveal, il client e l'attaccante non possono piu' usare Response.
restriction NoResponseAfterReveal:
  "not (Ex c s #i1 #i2.
    Reveal(c, s) @i1 &
    ResponseUsed(c, s) @i2 &
    #i1 < #i2)"

// Il server riceve la firma e verifica che la firma sia corretta.
rule Verify:
    [ In(<'Response', c, s, ch, sig>),
      ServerWaitingSIG(s, c, ch),
      !ServerPK(s, c, pkey) ]
  --[ VerifyUsed(c, s),
      Eq(verify(sig, ch, pkey), true),
      ServerAccepts(s, c, ch, sig) ]->
    [ ]

// Dopo la reveal, il server non puo' piu' fare la Verify.
restriction NoVerifyAfterReveal:
  "not (Ex c s #i1 #i2.
    Reveal(c, s) @i1 &
    VerifyUsed(c, s) @i2 &
    #i1 < #i2)"

// Diamo la possibilita' al client di autenticarsi anche dopo essere stato clonato.
rule ResponseVerify:
  let sig = sign(ch, skey)
  in
    [ In(<'Challenge', s, c, ch>),
      ServerWaitingSIG(s, c, ch),
      !ClientSK(c, s, skey),
      !ServerPK(s, c, pkey) ]
  --[ ResponseVerifyUsed(c, s),
      ClientResponds(c, s, ch, sig),
      Eq(verify(sig, ch, pkey), true),
      ServerAccepts(s, c, ch, sig) ]->
    [ ]

// Prima della reveal, il client non puo' usare ResponseVerify.
restriction OnlyResponseVerifyAfterReveal:
  "not (Ex c s #i2.
    ResponseVerifyUsed(c, s) @i2 &
    not (Ex #i1. Reveal(c, s) @i1 & #i1 < #i2))"

// Ogni volta che viene usata l'equazione Eq(x, y), x deve essere uguale a y.
restriction Equality:
  "All x y #i.
    Eq(x, y) @i
    ==>
    x = y"

// -----------------------------LEMMI DA DIMOSTRARE-----------------------------

// Se il server ha accettato un client, allora quest'ultimo deve aver risposto in precedenza.
lemma ServerAcceptsOnlyIfClientResponded:
  "All c s ch sig #i2.
    ServerAccepts(s, c, ch, sig) @i2 &
    not (Ex #i. Reveal(c, s) @i)
    ==>
    (Ex #i1. ClientResponds(c, s, ch, sig) @i1 & #i1 < #i2)"

// Se il client e' stato clonato, allora riesce comunque ad autenticarsi.
// Vero: Non esistono piu' i contatori.
lemma ClonedClientCanAuthenticate:
  "All c s ch sig #i1 #i2.
    Reveal(c, s) @i1 &
    ClientResponds(c, s, ch, sig) @i2 &
    #i1 < #i2
    ==>
    ServerAccepts(s, c, ch, sig) @i2"

// Non esiste piu' il contatore, quindi non esiste neanche il riallineamento.

end