theory HashChainWithNoDetection
begin

builtins: signing, hashing

// Un client genera una coppia di chiavi e si registra presso un server.
// Inizializzazione degli hash chain.
rule Setup:
    [ Fr(~sk),
      Fr(~nonce) ]
  --[ ClientRegisters($C, $S, ~sk, pk(~sk)) ]->
    [ !ClientSK($C, $S, ~sk),
      !ServerPK($S, $C, pk(~sk)),
      ClientH($C, $S, h(~nonce)),
      ServerH($S, $C, h(~nonce)),
      Out(pk(~sk)) ]

// Ogni client si puo' registrare ad uno stesso server al piu' una volta sola.
// Ogni client genera una coppia di chiavi per quello stesso server al piu' una volta sola.
restriction ClientRegistersOnce:
  "All c s skey1 skey2 pkey1 pkey2 #i #j.
    ClientRegisters(c, s, skey1, pkey1) @i &
    ClientRegisters(c, s, skey2, pkey2) @j
    ==>
    #i = #j"

// Rivela la chiave segreta (equivale alla clonazione).
// Simulazione di un'autenticazione riuscita dell'attaccante.
// L'hash chain del server viene modificato, ma quello del client resta invariato.
rule RevealSK:
  let sig = sign(~f_ch, skey)
      new_hash_s = h(<~f_ch, sig, old_hash_s>)
  in
    [ !ClientSK(c, s, skey),
      ServerH(s, c, old_hash_s),
      Fr(~f_ch) ]
  --[ Reveal(c, s) ]->
    [ ServerH(s, c, new_hash_s),
      Out(<skey, ~f_ch>) ]

// La reveal della chiave segreta di un client puo' essere fatta una sola volta.
restriction RevealOnce:
  "All c s #i #j.
    Reveal(c, s) @i &
    Reveal(c, s) @j
    ==>
    #i = #j"

// Il server invia una challenge al client.
rule Challenge:
    [ !ServerPK(s, c, pkey),
      Fr(~ch) ]
  --[ ServerSendsCH(s, c, ~ch) ]->
    [ ServerWaitingSIG(s, c, ~ch),
      Out(<'Challenge', s, c, ~ch>) ]

// Il client riceve la challenge, la firma, calcola l'hash e la invia al server.
rule Response:
  let sig = sign(ch, skey)
      next_hash = h(<ch, sig, hash>)
  in
    [ In(<'Challenge', s, c, ch>),
      ClientH(c, s, hash),
      !ClientSK(c, s, skey) ]
  --[ ClientResponds(c, s, ch) ]->
    [ ClientH(c, s, next_hash),
      Out(<'Response', c, s, ch, sig, next_hash>) ]

// Il server riceve la firma, confronta gli hash e verifica che la firma sia corretta.
rule Verify:
  let new_hash_s = h(<ch, sig, old_hash_s>)
  in
    [ In(<'Response', c, s, ch, sig, hash_c>),
      ServerWaitingSIG(s, c, ch),
      ServerH(s, c, old_hash_s),
      !ServerPK(s, c, pkey) ]
  --[ Eq(new_hash_s, hash_c),
      Eq(verify(sig, ch, pkey), true),
      ServerAccepts(s, c, ch) ]->
    [ ServerH(s, c, new_hash_s) ]

// Ogni volta che viene usata l'equazione Eq(x, y), x deve essere uguale a y.
restriction Equality:
  "All x y #i.
    Eq(x, y) @i
    ==>
    x = y"

// -----------------------------LEMMI DA DIMOSTRARE-----------------------------

// Se il server ha accettato un client e non e' stato clonato, allora quest'ultimo deve aver risposto in precedenza.
lemma ServerAcceptsOnlyIfClientResponded:
  "All c s ch #i3.
    ServerAccepts(s, c, ch) @i3 &
    not (Ex #i1. Reveal(c, s) @i1 & #i1 < #i3)
    ==>
    (Ex #i2. ClientResponds(c, s, ch) @i2 & #i2 < #i3)"

// Se il client e' stato clonato e prova ad autenticarsi, allora il server lo rifiuta.
// Falso: L'attaccante riallinea l'hash chain del client.
lemma ClonedClientCantAuthenticate:
  "All c s ch #i1 #i2.
    Reveal(c, s) @i1 &
    ClientResponds(c, s, ch) @i2 &
    #i1 < #i2
    ==>
    not (Ex #i3. ServerAccepts(s, c, ch) @i3 & #i2 < #i3)"

// Riallineamento banale dell'hash del client.
lemma ClientRealignmentExists:
  exists-trace
  "Ex c s skey pkey s_ch f_ch #i1 #i2 #i3 #i4 #i5 #i6.
    ClientRegisters(c, s, skey, pkey) @i1 &
    Reveal(c, s) @i2 &
    ClientResponds(c, s, f_ch) @i3 &
    ServerSendsCH(s, c, s_ch) @i4 &
    ClientResponds(c, s, s_ch) @i5 &
    ServerAccepts(s, c, s_ch) @i6 &
    #i1 < #i2 & #i2 < #i3 & #i3 < #i4 & #i4 < #i5 & #i5 < #i6 &
    // Limita eventuali altre response invocate dall'attaccante
    (All ch #i.
      ClientResponds(c, s, ch) @i
      ==>
      (#i = #i3 | #i = #i5))"

end