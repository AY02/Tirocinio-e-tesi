theory IdealModel
begin

builtins: signing, hashing, natural-numbers

// Limite sulla lunghezza degli hash chain per
// evitare loop infiniti sulle response.
restriction HashChainUpperBoundClient:
  "All c s n #i.
    ClientLength(c, s, n) @i
    ==>
    n << %1 %+ %1 %+ %1 %+ %1"

restriction HashChainUpperBoundServer:
  "All c s n #i.
    ServerLength(s, c, n) @i
    ==>
    n << %1 %+ %1 %+ %1 %+ %1"

// Un client si registra presso un server.
// Generazione di una coppia di chiavi.
// Inizializzazione degli hash chain.
rule Setup:
    [ Fr(~sk), Fr(~seed) ]
  --[ ClientRegisters($C, $S) ]->
    [ !ClientSK($C, $S, ~sk),
      !ServerPK($S, $C, pk(~sk)),
      !ClientHist($C, $S, h(~seed), %1),
      !ServerHist($S, $C, h(~seed), %1),
      ClientH($C, $S, h(~seed), %1),
      ServerH($S, $C, h(~seed), %1),
      Out(pk(~sk)) ]

// Un client si puÃ² registrare presso uno stesso server non piu' di una volta.
restriction ClientRegistersOnce:
  "All c s #i #j.
    ClientRegisters(c, s) @i &
    ClientRegisters(c, s) @j
    ==>
    #i = #j"

// Rivela la chiave segreta (equivale alla clonazione).
// L'attaccante si autentica con successo con il server.
// L'hash chain del server viene modificato.
// Quello del client resta invariato.
rule RevealSK:
  let r_ch = <~f_nonce, ~ch>
      sig = sign(r_ch, ~skey)
      next_hash_s = h(<r_ch, sig, hash_s>)
  in
    [ !ClientSK($C, $S, ~skey),
      ServerH($S, $C, hash_s, %len),
      Fr(~ch), Fr(~f_nonce) ]
  --[ Reveal($C, $S),
      ServerLength($S, $C, %len %+ %1) ]->
    [ !ServerHist($S, $C, next_hash_s, %len %+ %1),
      ServerH($S, $C, next_hash_s, %len %+ %1),
      Out(<~skey, ~f_nonce, ~ch>) ]

// La reveal di una chiave privata del client si puo' fare non piu' di una volta.
restriction RevealOnce:
  "All c s #i #j.
    Reveal(c, s) @i &
    Reveal(c, s) @j
    ==>
    #i = #j"

// Il server invia una challenge al client.
rule Challenge:
    [ !ServerPK($S, $C, pkey),
      Fr(~ch) ]
  --[ ServerSendsCH($S, $C, ~ch) ]->
    [ ServerWaitingSIG($S, $C, ~ch),
      Out(<'Challenge', $S, $C, ~ch>) ]

// Il client riceve la challenge.
// Aggiunge della randomness.
// Firma la challenge.
// Calcola l'hash.
rule Response:
  let r_ch = <~nonce, ch>
      sig = sign(r_ch, ~skey)
      next_hash = h(<r_ch, sig, hash>)
  in
    [ In(<'Challenge', $S, $C, ch>),
      !ClientSK($C, $S, ~skey),
      ClientH($C, $S, hash, %len),
      Fr(~nonce) ]
  --[ ClientResponds($C, $S, ch),
      ClientLength($C, $S, %len %+ %1) ]->
    [ !ClientHist($C, $S, next_hash, %len %+ %1),
      ClientH($C, $S, next_hash, %len %+ %1),
      Out(<'Response', $C, $S, r_ch, sig, next_hash>) ]

// Il client invia la response, ma viene persa.
rule ResponseLost:
  let r_ch = <~nonce, ch>
      sig = sign(r_ch, ~skey)
      next_hash = h(<r_ch, sig, hash>)
  in
    [ In(<'Challenge', $S, $C, ch>),
      !ClientSK($C, $S, ~skey),
      ClientH($C, $S, hash, %len),
      Fr(~nonce) ]
  --[ ClientLosesResponse($C, $S, ch),
      ClientLength($C, $S, %len %+ %1) ]->
    [ !ClientHist($C, $S, next_hash, %len %+ %1),
      ClientH($C, $S, next_hash, %len %+ %1) ]

// Il server autentica il client.
rule Verify:
  let r_ch = <nonce, ~ch>
      new_hash_s = h(<r_ch, sig, hash_s>)
  in
    [ In(<'Response', $C, $S, r_ch, sig, hash_c>),
      ServerWaitingSIG($S, $C, ~ch),
      ServerH($S, $C, hash_s, %len),
      !ServerPK($S, $C, pkey) ]
  --[ Eq(new_hash_s, hash_c),
      Eq(verify(sig, r_ch, pkey), true),
      ServerAccepts($S, $C, ~ch),
      ServerLength($S, $C, %len %+ %1) ]->
    [ !ServerHist($S, $C, new_hash_s, %len %+ %1),
      ServerH($S, $C, new_hash_s, %len %+ %1) ]

// Il server non autentica il client
// perche' l'hash non e' corretto.
rule VerifyFail:
  let r_ch = <nonce, ~ch>
      new_hash_s = h(<r_ch, sig, hash_s>)
  in
    [ In(<'Response', $C, $S, r_ch, sig, hash_c>),
      ServerWaitingSIG($S, $C, ~ch),
      !ServerHist($S, $C, hash_s, %len),
      !ServerPK($S, $C, pkey) ]
  --[ Neq(new_hash_s, hash_c),
      Eq(verify(sig, r_ch, pkey), true),
      ServerRejects($S, $C, ~ch) ]->
    [ ]

// Ogni volta che viene usato Eq(x, y), x deve essere uguale a y.
restriction Equality:
  "All x y #i. Eq(x, y) @i ==> x = y"

// Ogni volta che viene usato Neq(x, x), si ha una contraddizione.
restriction Inequality:
  "All x #i. Neq(x, x) @i ==> F"

// LEMMI----------------------------------------------------------

// Diamo "conoscenza" all'oracolo sul fatto che le catene sono
// strettamente crescenti.
lemma StrictlyIncreasingClient [reuse, use_induction]:
  "All c s len1 len2 #i1 #i2.
    ClientLength(c, s, len1) @i1 &
    ClientLength(c, s, len2) @i2 &
    #i1 < #i2
    ==>
    len1 << len2"

lemma StrictlyIncreasingServer [reuse, use_induction]:
  "All c s len1 len2 #i1 #i2.
    ServerLength(s, c, len1) @i1 &
    ServerLength(s, c, len2) @i2 &
    #i1 < #i2
    ==>
    len1 << len2"

// Se il server ha autenticato un client (non clonato),
// allora quest'ultimo deve aver risposto in precedenza.
lemma ServerAcceptsOnlyIfClientResponded:
  "All c s ch #i2.
    ServerAccepts(s, c, ch) @i2 &
    not (Ex #i. Reveal(c, s) @i)
    ==>
    (Ex #i1. ClientResponds(c, s, ch) @i1 & #i1 < #i2)"

// Se il client clonato prova ad autenticarsi,
// allora il server rifiuta l'autenticazione.
// Vero: L'attaccante non e' in grado di riallineare l'hash chain del client.
lemma ClonedClientCantAuthenticate:
  "All c s ch #i1 #i2.
    Reveal(c, s) @i1 &
    ClientResponds(c, s, ch) @i2 &
    #i1 < #i2
    ==>
    not (Ex #i3. ServerAccepts(s, c, ch) @i3 & #i2 < #i3)"

// Riallineamento banale dell'hash chain del client.
// Falso: L'attaccante non puo' piu' riallineare.
lemma ClientRealignmentExists:
  exists-trace
  "Ex c s s_ch f_ch #i1 #i2 #i3 #i4 #i5 #i6.
    ClientRegisters(c, s) @i1 &
    Reveal(c, s) @i2 &
    ClientResponds(c, s, f_ch) @i3 &
    ServerSendsCH(s, c, s_ch) @i4 &
    ClientResponds(c, s, s_ch) @i5 &
    ServerAccepts(s, c, s_ch) @i6 &
    #i1 < #i2 & #i2 < #i3 & #i3 < #i4 & #i4 < #i5 & #i5 < #i6"

// Scenario catturato (banale):
// L'attaccante fa fare delle response al client per impedire l'autenticazione.
// Le fake response vengono fatte prima della response legittima.
lemma FakeResponseRejectedExists:
  exists-trace
  "Ex c s ch #i1 #i2.
    not (Ex #i. Reveal(c, s) @i) &
    ClientResponds(c, s, ch) @i1 &
    ServerRejects(s, c, ch) @i2 &
    #i1 < #i2"

// Scenario proposto: Il client invia due response su una challenge legittima.
// La prima response viene persa, mentre la seconda arriva al server.
lemma HonestResponseRejectedExists:
  exists-trace
  "Ex c s ch #i1 #i2 #i3.
    not (Ex #i. Reveal(c, s) @i) &
    ClientLosesResponse(c, s, ch) @i1 &
    ClientResponds(c, s, ch) @i2 &
    ServerRejects(s, c, ch) @i3 &
    #i1 < #i2 & #i2 < #i3"

// Se il client (non clonato) perde una response e ne invia un'altra,
// allora il server non lo autentichera' mai.
lemma ResponseFailureDetection:
  "All c s ch #i1 #i2.
    not (Ex #i. Reveal(c, s) @i) &
    ClientLosesResponse(c, s, ch) @i1 &
    ClientResponds(c, s, ch) @i2 &
    #i1 < #i2
    ==>
    not (Ex #i3. ServerAccepts(s, c, ch) @i3 & #i2 < #i3)"

end