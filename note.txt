Tenere sempre l'approccio challenge-response senza clientRequestAuth.

Refactoring e renaming:
Challenge <-> SendChallenge
Response <-> Reply
Complete <-> Verify
Questi sono i tre termini convenzionali.

Facoltativo:
- Le contromisure sign(<ch, s>) sono vulnerabili a sessioni parallele.
- Contromisura piu' efficiente: sign(<ch, sid>), sid = Session ID.

-------------------------------------------
Ho tolto la Reveal della sk, adesso provo a rimetterla e modifico il lemma ClientResponded.

C --> S1
C --> S2

Crittografia simmetrica

Se S2 e S1 hanno la stessa password, ma S2 ha la password rivelata, allora S1 e' violabile.

Perche' non si puo' fare direttamente KU?
Se fai la reveal su S2, non puoi vincere banalmente su S2, ma vinci se riesci a violare S1.

-------------------------------------------
Rilevazione di cloni

Automatically deteching the misure of secrets, Cremers

Bindel FIDO2


id -> identita' (nome) del server
h -> challenge

il client e' il browser, mentre il token e' la chiave.
(client e token si possono sovrapporre).
Ogni token ha una memoria.
rc_T = Registration context del token T.
E' la memoria persistente di quel token T. Implementato come un dizionario.
rc_T[id] --> Informazioni salvate quando ti sei registrato al server id.
sign(rc_T[id].sk, (ad, h))
h ==> challenge
ad ==> Struttura complessa: H(id), rc_t[id].n
- H(id) => Hash dell'identita' del server
- rc_t[id].n => Contatore locale di id (lato client)
Ad ogni sessione della response, aumento il contatore di uno.

Mi invento delle challenge e ti faccio fare delle firme per incrementare il contatore.

A me non interessa:
- Facoltativo: Nel protocollo vero, l'id del server mittente e' un informazione
affidabile perche' e' in una connessione sicura.
- Il client e' stateless.

rc = registration context

Il server fa questa cosa:
n <= rc_s[cid].n (cid = client ID)
Anche il server ha un suo contatore
Riceve il contatore del client
Se minore uguale, allora rifiuto l'autenticazione
Se accetto (maggiore, cioe' il client n + 1 oppure se l'attaccante provoca dei +1 al client):
- Imposto rc_s[cid].n = n
E' stateful, mentre di solito e' stateless.

A che serve il contatore?
Opinione del prof:
- Potrebbero esserci delle vulnerabilita' senza mettere vincoli aggiuntivi
- Viene usato per il clone detection

Cosa sono i cloni?
Nel contesto di FIDO, l'attacco cloning consiste nel prendere un token (client) e ne creo una copia (lo cloni).
Reveal(token).
Anche se fa una Reveal, non riesce ad autenticarsi perche' il server rifiuterebbe.
Se il client originale non lo usasse mai, in realta' l'attaccente riuscirebbe ad autenticarsi.
Ma ad un certo punto, se il proprietario lo continua ad usare, avrei due token paralleli che continua ad autenticarsi.
Inevitabilmente uno dei due rimane indietro con il proprio contatore.

E' solo per detection del server, non interessa sapere chi e' l'attaccante o il proprietario.
E' solo un avviso di anomalia.

Consentire all'avversario di vincere anche se c'e' stata una Reveal.

La Reveal e' una clone. Puoi vincere se non c'e' una reveal.
Nell'esempio originale v2, se c'e una reveal, l'attaccante vince.

Se nell'autenticazione c'e' un contatore.
Anche se c'e' la reveal, non vincere.

In realta' l'attaccante vincera' comunque:
- Perche'?

Rubo soltanto le informazioni riguardo ad un server, oppure esiste una Reveal globale "rubo tutto" di tutti i server.
Fare reveal globale, che e' piu facile.

Reallineamento lato client:
- Attaccante rubo tutto del client
- L'attaccante si continua ad autenticare, aumentando il suo contatore e quello del server
- Se l'onesto resta indietro, si vedra' rifiutato
Non vogliamo che questo avvenga.
Il server, richiesto dall'attaccante, fa eseguire tante response fasulle al client per reallinearlo.
E' l'attaccante che fa eseguire tante response fasulle.
Il server non se ne accorgera' mai!
Come lo fa l'attaccante?
L'attaccante esegue tante ClientSendsResponse per conto del client, come se fosse un server malevolo.

Difficile da fare.
Alternativa: Quando faccio la Reveal, forzare un'autenticazione presso un server senza invocare la response del client onesto,
cioe' usando una response dell'attaccante e senza far aumentare il contatore del client.

Intende dire che se viene fatta la Reveal, il client non sara' piu' in grado di fare richieste di autenticazione, ma solo l'attaccante potra' farle?
Oppure intende dire che il client le puo' fare, ma l'attaccante le intercetta in modo tale da modificare il contatore con quello dell'attaccante?

Condizione di vittoria:
- Se un client, che ha subito una reveal, riesce ad autenticarsi correttamente, allora il sistema non e' sicuro
  ==> Perch√© l'attaccante ha riallineato
- ClientResponded

Solo la chiave segreta e' privata, facoltativo per i contatori.

Authenticate
Pagina 1418
FIDO2, CTAP 2.1, and







Quando faccio la Reveal, devo forzare un'autenticazione con il server.
Autenticazione dell'avversario.
L'attaccante puo' inviare il contatore che vuole lui.
Il server riceve il contatore del client, ma non modifica il suo contatore (del server).

Attaccante fa la reveal, ottiene sk.
Poi fa una response spacciandosi per il client.
Poi il server fa la verify.

Non posso fare response una volta che ho fatto la Reveal.

regola alternativa:


Il client non puo' piu' fare response, ma gli diamo un altro modo in cui fa response-verify.
Perche' sto emulando un contesto in cui un'autenticazione in cui la response non viene persa.

Se c'e' reveal, non fare la response al client.
Non va bene, banalmente accettato.

ResponseVerify: L'attaccante fa fare delle response al client e quest'ultime verranno sicuramente verificate dal client se si usano contatori.
Pero' coi contatori 

Provare a farlo con e senza contatore.

// Verificare che il client abbia sempre un contatore piu' grande del server
// L'attaccante clona e si autentica con il server.


********************************************************************************************************************************

HASH HASH HASH CHAIN CHAIN CHAIN

Con le chain hash, non ci devono essere upper bound.

Problema:
I sistemi di clone detection tramite contatori sono trace-independent, cioe':
- Il client viene clonato in stato S1_1 (originale) e S2_1 (attaccante)
- Al momento del clonaggio, vale che S1_1 = S2_1
- Al momento dell'autenticazione dell'attaccante con la challenge X del server, allora S2_1 si trasforma S2_2
- Quando l'attaccante invia una challenge Y al client, allora S1_1 si trasforma in S1_2
- L'obiettivo e' quello di far equivalere S2_2 con S1_2
- Se tramite due challenge diverse X != Y si ha che S_2 = S_1, allora la detection si dice trace-independent
Anche usando challenge diverse, si ottiene comunque lo stesso stato (contatore).

Cos'e' una chain hash?
Dato un d_0 = H(...), allora d_i(v) = H(v|d_i-1).
Il protocollo e' stateful, cioe' gli attori mantengono gli stati della chain hash.

Setup del client e del server:
- d_0 = H(random)

Il server invia una challenge X al client.
Il client calcola la response R e poi fa d_1_c = H(<X, R>, d_0) e lo invia al server.
Il server riceve la response R e calcola anche lui d_1 = H(<X, R>|d_0), verificando che d_0 = d_0 del client.

L'attaccante clona il client e copia la sua chain hash d.
L'attaccante invia una challenge X al client.
Il client calcola la response R1 e poi fa d_2 = H(<X, R1>, d_1).

Il server invia una challenge Y al client.
Il client calcola la response R2 e poi fa d_3 = H(<Y, R2>, d_2) e lo invia al server.
Il server riceve la response R2 e calcola anche lui d_2 = H(<Y, R2>|d_3), verificando che d_1 = d_3 del client.
Il server vede che d_1 != d_3 ==> Clone detection!


Ogni volta che il server riceve una response dal client, allora aggiorna il suo chain hash con la risposta del client.
==> Accumulatore crittografico.
Nella hash si mette la challenge, la response e lo stato precedente.
Poi si va a firmare l'hash.

Problema:
L'attaccante invia tante challenge al client.
Il client aggiorna il suo stato, ma e' disallineato con il server.
Il client e il server non possono piu' a comunicare.

L'attaccante si autentica e poi riallinea.

Diamo l'abilita' del client di rifiutare le response che non sono del server.
Per ogni challenge-response-verify, il client salva un fatto.
Tuttavia, la response ha un po' di randomness.
Il server autentica il client, ma quando un attaccante invia una challenge al client, quest'ultimo generera' una cosa
diversa!

********************************************************************************************************

Meccanismo di self-healing:
Ripristinare lo stato violato del client.
Non esiste self-healing senza dati random.
Se ad ogni transazione ci fosse un po' di randomness generato dal client stesso, allora puo' essere possibile
fare operazioni di self-healing.


********************************************************************************************************
Il client salva ogni response e challenge fatta (mondo ideale).
Praticamente salvo l'intera traccia.
Quando faccio il cloning, l'attaccante prende anche tutte le tracce salvate dal client.


(Non ha resinking, "se faccio delle response")
Nella vita reale esistono accumulatori a bassa memoria con crittografia asimmetrica.