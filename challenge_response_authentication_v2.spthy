theory ChallengeResponseAuthenticationDigitalSignature
begin

builtins: signing

// Un clinet 

// Ogni client genera una coppia di chiavi (privata, pubblica)
rule Setup:
  [ Fr(~sk) ]
  --[ ClientRegisters($Client) ]->
  [ !ClientSK($Client, ~sk),
    !ServerPK('Server', $Client, pk(~sk)),
    Out(pk(~sk)) ]

/*
// Un client richiede l'autenticazione al server
rule ClientSendsAuthRequest:
  [ !ClientSK($Client, sk) ]
  --> [ ClientWaitingChallenge($Client, sk),
        Out(<'AuthRequest', $Client>) ]
*/

// Il server invia una challenge al client
rule ServerSendsChallenge:
  [ //In(<'AuthRequest', $Client>),
    !ServerPK('Server', $Client, pk),
    Fr(~nonce) ]
  --> [ ServerWaitingSignature('Server', $Client, ~nonce, pk),
        Out(<$Client, ~nonce>) ]

// Il client firma h(nonce) e lo invia al server
// Troppo semplice, vanno aggiunte delle cose: Accettare un'entita'
// Chi e' l'entità? Del server
// Ci sono più server, non piu' una sola
// Usare una stessa chiave per più identità è insicuro
// Un client che ignora l'dentità e usa un valorep rivato
// Se io ti faccio autenticare con con un'altra identità che non è la tua, allora ho vinto
rule ClientSendsResponse:
  [ In(<$Client, nonce>),
    !ClientSK($Client, sk) ]
  --[ ClientResponds($Client, nonce) ]->
  [ Out(<$Client, sign(nonce, sk)>) ]

// Il server riceve il digest firmato e verifica che sia corretto
// Il server accetta solo se l'equazione e' verificata
rule ServerVerifiesResponse:
  [ In(<$Client, signature>),
    ServerWaitingSignature('Server', $Client, nonce, pk) ]
  --[ Eq(verify(signature, nonce, pk), true),
      ServerAccepts('Server', $Client, nonce) ]->
  []

rule RevealSK:
  [!ClientSK($Client, sk)]--[Reveal($Client)]->[Out(sk)]

// Ogni volta che viene usata l'equazione Eq(x, y), x deve essere uguale a y
restriction Equality:
  "All x y #i. Eq(x,y) @i ==> x = y"

// Non possono esistere client con più di una chiave privata
restriction ClientHasOneKey:
  "All client #i #j.
    ClientRegisters(client) @i & ClientRegisters(client) @j 
    ==> #i = #j"

// Lemma 1: Se il server ha accettato un client, allora quest'ultimo deve aver risposto prima
lemma client_authentication:
  "All client nonce #i.
    ServerAccepts('Server', client, nonce) @i &
    not (Ex #z. Reveal(client) @z & z < i)
    ==>
    (Ex #j. ClientResponds(client, nonce) @j & j < i)"

// Qualcosa che rimane sicuro senza reveal, ma che diventa insicuro con il reveal
// Malleabilità

end

/*

Esercizio:
- Toy example che diventa insicuro con una reveal (studiare le correlazioni tra chiavi private e pubbliche)
- 

Protocollo FIDO
WebAuthn.io

Posso registrare questi dispositivi per tanti servizi diversi
Autenticazione multifattore

Provare ad estendere questo tipo di approccio tramite un sistema multi chiave (Verifier-prover con più chiavi)

Non è un semplice inoltro quello che fa il browser (client)
canale cli - ser sicuro e il cli conosce l'identita' del server

L'attaccante si spaccia per il client per autenticarsi al server

REGISTER esplicita (forse può essere omessa su Tamarin)
Challenge
Response
Complete <--> Verify

Cosa significa fare la registrazione?
Vittoria espressa in termini di identità e non di chiave.

//SSO con C S V (Service provider)
/*

Server: Identity provider
V: Servicce provder
Authentication : CR auth

S fa la release
La release lo manda a V
Opzionale: Fase begin tra C e V perché il client deve generare dei nonce prima di fare l'invio

Attacco:
Esiste un altro client che attacca il processo di auth
Finise lui l'autenticazione del client.
Quindi C conserva dei dati privati che verranno trasmessi sono alla fine


*/