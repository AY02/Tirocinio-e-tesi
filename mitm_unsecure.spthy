theory ManInTheMiddleAttackUnsecure
begin

builtins: signing

/*

Premesse:
- C'e' piu' di un client
- C'e' piu' di un server
- Il client utilizza una sola coppia di chiavi per accedere a tutti i server

Attacco:
1) Un client invia una auth request a S1 e a S2.
2) S1 invia una challenge al client, ma viene intercettato dall'attaccante.
3) L'attaccante si spaccia per S2 ed invia la challenge intercettata al client.
4) Il client invia una response all'attaccante.
5) L'attaccante si autentica ad S1 usando la response.

*/

// Un client genera una coppia di chiavi (privata, pubblica).
rule ClientSetup:
    [ Fr(~sk) ]
  --[ ClientGeneratesPair($C, ~sk, pk(~sk)) ]->
    [ !ClientSK($C, ~sk),
      !ClientPK($C, pk(~sk)),
      Out(pk(~sk)) ]

// Ogni client ha una sola coppia di chiavi.
restriction ClientHasOnePair:
  "All c skey1 skey2 pkey1 pkey2 #i #j.
    ClientGeneratesPair(c, skey1, pkey1) @i
    & ClientGeneratesPair(c, skey2, pkey2) @j
    ==>
    #i = #j"

// Un client si registra presso un server.
rule ClientRegistration:
    [ !ClientPK(c, pkey) ]
  --[ ClientRegisters(c, $S, pkey) ]->
    [ !ServerPK($S, c, pkey) ]

// Ogni client si può registrare ad un server al più una volta.
restriction ClientRegistersOnce:
  "All c s pkey #i #j.
    ClientRegisters(c, s, pkey) @i
    & ClientRegisters(c, s, pkey) @j
    ==>
    #i = #j"

// Un client invia una auth request al server.
rule ClientSendsAuthRequest:
    [ !ServerPK(s, c, pkey) ]
  --[ ClientRequestsAuth(c, s) ]->
    [ ClientWaitingChallenge(c, s),
      Out(<'Request', c, s>) ]

// Il server invia una challenge al client.
rule ServerSendsChallenge:
    [ In(<'Request', c, s>),
      !ServerPK(s, c, pkey),
      Fr(~ch) ]
  --[ ServerSendsChallenge(s, c, ~ch) ]->
    [ ServerWaitingResponse(s, c, ~ch),
      Out(<'Challenge', s, c, ~ch>) ]

// Il client firma la challenge e la invia al server.
rule ClientSendsResponse:
    [ In(<'Challenge', s, c, ch>),
      ClientWaitingChallenge(c, s),
      !ClientSK(c, skey) ]
  --[ ClientResponds(c, s, ch, sign(ch, skey)) ]->
    [ Out(<'Response', c, s, ch, sign(ch, skey)>) ]
    // sign(<challenge, $Server>, sk) Identita' del server non inclusa => L'attaccante puo' riutilizzare la response.

// Si puo' rispondere ad una challenge solo una volta.
restriction ChallengeUsedOnce:
  "All c s ch sig #i #j.
    ClientResponds(c, s, ch, sig) @i
    & ClientResponds(c, s, ch, sig) @j
    ==>
    #i = #j"

// Il server verifica la response e autentica il client.
rule ServerVerifiesResponse:
    [ In(<'Response', c, s, sig>),
      ServerWaitingResponse(s, c, ch),
      !ServerPK(s, c, pkey) ]
  --[ Eq(verify(sig, ch, pkey), true),
      ServerAccepts(s, c, ch, sig) ]->
    [ ServerAuthenticated(s, c, ch, sig) ]

// Ogni volta che viene usata l'equazione Eq(x, y), x deve essere uguale a y.
restriction Equality:
  "All x y #i.
    Eq(x,y) @i
    ==>
    x = y"

// ====================SCENARIO DI ATTACCO========================

// L'attaccante intercetta la challenge inviata da S1 a C.
rule RevealChallenge:
    [ In(<'Challenge', $S1, $C, ch>) ]
  --[ AdvInterceptsChallenge($S1, $C, ch) ]->
    [ AdvKnowsChallenge($S1, $C, ch) ]

// L'attaccante, spacciandosi per S2, invia la challenge intercettata al client.
rule ForwardsChallenge:
    [ AdvKnowsChallenge($S1, $C, ch) ]
  --[ AdvForwardsChallenge($S1, $S2, $C, ch) ]->
    [ Out(<'Challenge', $S2, $C, ch>) ]

// L'attaccante usa la response del client per autenticarsi con S1.
rule ForwardsResponse:
    [ In(<'Response', $C, $S2, sig>) ]
  --[ AdvForwardsResponse($S2, $S1, $C, sig) ]->
    [ Out(<'Response', $C, $S1, sig>) ]

// ====================PROPRIETA' DA VERIFICARE====================

// Esiste l'attacco?
lemma AttackPossible:
  exists-trace
  "Ex c s1 s2 skey pkey ch sig #a #b #c #d #e #f #g #h #i #l #m.
    ClientGeneratesPair(c, skey, pkey) @ #a
    & ClientRegisters(c, s1, pkey) @ #b
    & ClientRegisters(c, s2, pkey) @ #c
    & ClientRequestsAuth(c, s1) @ #d
    & ClientRequestsAuth(c, s2) @ #e
    & ServerSendsChallenge(s1, c, ch) @ #f
    & AdvInterceptsChallenge(s1, c, ch) @ #g
    & AdvForwardsChallenge(s1, s2, c, ch) @ #h
    & ClientResponds(c, s2, ch, sig) @ #i
    & AdvForwardsResponse(s2, s1, c, sig) @ #l
    & ServerAccepts(s1, c, ch, sig) @ #m
    & #a < #b & #b < #c & #c < #d & #d < #e & #e < #f & #f < #g & #g < #h & #h < #i & #i < #m
    & not(s1 = s2)"

// Se il server accetta un client, allora quel client ha risposto.
lemma ClientResponded:
  "All s c ch sig #i.
    ServerAccepts(s, c, ch, sig) @i
    ==>
    (Ex #j. ClientResponds(c, s, ch, sig) @j & #j < #i)"

// Se il server invia una challenge, allora ha il client lo ha richiesto.
// Non e' rispettato: L'attaccante puo' inviare la request.
lemma ChallengeFollowsRequest:
  "All s c ch #i.
    ServerSendsChallenge(s, c, ch) @i
    ==>
    (Ex #j. ClientRequestsAuth(c, s) @j & #j < #i)"

end